== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/00-notes ==
अक्सर जब हम कंप्यूटर फ़ाइलों से निपटते हैं तो हम पाते हैं कि
हमें कुछ फ़ाइलों का नाम बदलने की ज़रूरत पड़ सकती है जबकि अन्य फ़ाइलों को अपरिवर्तित छोड़ना पड़ सकता है।
=====
== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/01-notes ==
आज मैं एक तकनीक का प्रदर्शन करना चाहूँगा जो मुझे stackflow.com पर मिली है
मेरी पृष्ठभूमि कंप्यूटर विज्ञान में है
इसलिए मैं लिनक्स का उपयोग करने में सबसे अधिक सहज हूँ और इसलिए मैं एक खोज कमांड का उपयोग करके प्रदर्शन करूँगा, हालाँकि Microsoft ने Powershell विकसित किया है, जो इस स्क्रिप्ट के बहुत से काम करता है;
यह तकनीक उस तकनीक में भी संभव हो सकती है।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/02-notes ==
find एक Linux कमांड है जो एक फ़ोल्डर और उसके
चाइल्ड डायरेक्टरीज़ में स्ट्रिंग पैटर्न के लिए पुनरावर्ती रूप से खोज करता है। यह खोज का एक पसंदीदा तरीका है क्योंकि यह खोज का एक थ्रेडेड निष्पादन प्रतीत होता है।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/03-notes ==
थ्रेडिंग किसी प्रोग्राम को समवर्ती रूप से निष्पादित करने का एक शानदार तरीका है, या सीधे शब्दों में कहें तो हम प्रोग्रामिंग के एक हिस्से को स्टॉप कंडीशन के साथ बार-बार निष्पादित करते हैं। चूँकि आज का वीडियो थ्रेडिंग के बारे में नहीं है, इसलिए हम इस सरलीकृत परिभाषा का उपयोग कर सकते हैं। =====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/04-notes ==
चूंकि find एक कमांड है जो रिकर्सन पर काम करता है, इसलिए कुछ सावधानी बरतनी चाहिए ताकि केवल उन फ़ोल्डरों को खोजा जा सके जिन्हें हम खोजना चाहते हैं, इसलिए उदाहरण के लिए पूरे फ़ाइल सिस्टम पर इस तकनीक का उपयोग करना नासमझी होगी। =====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/05-notes ==
तो चलिए इस सरल स्क्रिप्ट के माध्यम से आगे बढ़ते हैं: =====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/06-notes ==
पहली पंक्ति "#!/usr/bin/env bash" पहले पारंपरिक "#!/usr/bin/bash" पर अजीब लग सकती है। पारंपरिक शा बैंग मानता है कि bash प्रोग्राम वहीं है जहाँ उसे होना चाहिए। स्क्रिप्ट में यह लाइन यह धारणा नहीं रखती है, बल्कि यह कहती है कि बैश प्रोग्राम $PATH में कहीं है। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/07-notes == फ़ंक्शन नाम बदलें() एक पुन: प्रयोज्य कमांड या कोड का टुकड़ा बनाने के लिए हम फ़ंक्शन बनाते हैं, निम्नलिखित है कि स्क्रिप्टिंग फ़ंक्शन कैसे लिखा जाता है। शेल स्क्रिप्टिंग में, फ़ंक्शन सामान्य रूप से प्रोग्रामिंग से अलग तरीके से काम करते हैं। एक फ़ंक्शन, जैसा कि नाम से पता चलता है, एक मान लौटाता है। हालाँकि स्क्रिप्टिंग में, फ़ंक्शन सबरूटीन की तरह काम करते हैं, जिसमें वे वास्तव में कुछ भी नहीं लौटाते हैं। फ़ंक्शन में मान कैसे पास किए जाते हैं, इसमें अन्य अंतर देखे जा सकते हैं। प्रोग्रामिंग में, हम फ़ंक्शन नाम के पास पैरामीटर सूचीबद्ध करते हैं, लेकिन हम जल्द ही देखेंगे कि पैरामीटर स्पष्ट के बजाय निहित हैं। =====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/08-notes ==
local old=$1
local new=$2

अब संक्षेप में फ़ंक्शन बनाम वैश्विक चर के बारे में बात करने के लिए एक अच्छी जगह हो सकती है। फ़ंक्शन चर
केवल उसी फ़ंक्शन के भीतर उपयोग करने योग्य होने चाहिए जिसमें इसे परिभाषित किया गया था। कोड को पुन: प्रयोज्य बनाने के लिए
, फ़ंक्शन परमाणु होना चाहिए; अपने आप संचालित होने की क्षमता होनी चाहिए।

इसलिए परमाणु की भावना में हम कीवर्ड "स्थानीय" में पहला उदाहरण देखते हैं; हम केवल इन चर को फ़ंक्शन के अंदर से एक्सेस करने योग्य बनाना चाहते हैं। इस कीवर्ड के बिना हम इन चर के मानों को एक्सेस कर सकते हैं और संभवतः बदल सकते हैं जिससे त्रुटियों को ढूंढना कठिन हो जाता है।

शेल स्क्रिप्टिंग में जब हम "$" देखते हैं तो हम मान लेते हैं कि यह चर है, फिर भी संख्या विषम हो सकती है।
स्क्रिप्टिंग करते समय हम नाम से नहीं बल्कि स्थिति से पैरामीटर का संदर्भ देते हैं, इसलिए $1 का अर्थ है पहला पैरामीटर पास किया गया।
मापदंडों की गिनती 0 से नहीं बल्कि 1 से शुरू होती है।
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/09-notes ==
find

अगली पंक्ति में हम वास्तविक कमांड देखते हैं। find को पहले ही पहचान लिया गया है, लेकिन फिर से बता दें कि यह एक ऐसा प्रोग्राम है जो स्ट्रिंग या शाब्दिक पैटर्न की पुनरावर्ती खोज करने के लिए थ्रेड का उपयोग करता है।
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/10-notes ==
find .

find प्रोग्राम के बाद हम प्रोग्राम को दिए गए तर्क देखते हैं। तर्क या कभी-कभी
फ्लैग कहे जाने वाले, प्रोग्रामिंग में प्रोग्राम को कुछ खास सुविधाओं को निष्पादित करने के लिए मार्गदर्शन प्रदान करने के लिए उपयोग किए जाते हैं।

यहाँ हमारा पहला तर्क एक अवधि है, जिसका अर्थ है कि इस संदर्भ में, वर्तमान निर्देशिका या फ़ोल्डर में खोज शुरू करें यदि आप चाहें। इस अवधि को किसी भी निर्देशिका पर इंगित करने के लिए बदला जा सकता है, एक सुझाव हमेशा पूर्ण या निरपेक्ष पथ का उपयोग करना होगा।
खोज कमांड के लिए यह वास्तव में परवाह नहीं करता है कि आप निरपेक्ष या सापेक्ष पथ का उपयोग करते हैं, लेकिन यदि आप एक बड़ी स्क्रिप्ट फ़ाइल का उपयोग कर रहे हैं तो यह अधिक पठनीय है।
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/11-notes ==
find . -type f

अगला हम देखते हैं -type f जिसका अर्थ है केवल फ़ाइलों की तलाश करें, हालाँकि हम फ़ोल्डरों की तलाश कर सकते हैं
-type d.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/12-notes ==
find . -type f -name "*${old}"

यदि आपको याद होगा तो हमने उल्लेख किया था कि खोज एक कमांड है जो स्ट्रिंग पैटर्न के लिए पुनरावर्ती रूप से खोज करेगी।
हम "स्ट्रिंग पैटर्न" क्यों कहते हैं और केवल "स्ट्रिंग" क्यों नहीं? अच्छा सवाल है, एक पैटर्नसुझाव है कि हम सटीक मिलान की तलाश नहीं कर रहे हैं, बल्कि आंशिक मिलान की तलाश कर रहे हैं। * द्वारा निर्दिष्ट आंशिक मिलान केवल स्ट्रिंग के साथ समाप्त होने वाली किसी भी चीज़ को दर्शाता है, इस मामले में $old। यह एक अन्य अवधारणा में आता है जिसे नियमित अभिव्यक्ति कहा जाता है, लेकिन यह इस वीडियो के दायरे से बाहर है। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/13-notes == find . -type f -name "*${old}" -execdir यह वह जगह है जहाँ हम फ्लैग -execdir के साथ इस कमांड की शक्ति पाते हैं। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/14-notes == find . -type f -name "*${old}" -execdir sh -c Execdir न केवल एक फ्लैग है, बल्कि अपने आप में एक कमांड भी है। ऐसा कहा जाता है कि sh -c -execdir के लिए तर्क हैं जो इसे बताते हैं कि किस शेल को निष्पादित करना है। विडंबना यह है कि sh बोर्न शेल है जबकि स्क्रिप्ट को bash का उपयोग करने के लिए कहा जाता है: #!/usr/bin/env bash. यह कैसे संभव है? 1. बोर्न अधिकांश लिनक्स वितरण में स्थापित है, फिर भी bash मुख्य रूप से केवल डेबियन के लिए है। सभी लिनक्स सिस्टम समान नहीं हैं, वितरण और शेल का यह विषय इस वीडियो के दायरे से बाहर है। 2. mv, echo और sed कमांड बोर्न और bash दोनों शेल में शामिल हैं। कोई भी शेल इन कमांड को पढ़ और निष्पादित कर सकता है। -c एक शेल फ्लैग बोर्न\bash है जो इसे निम्न स्ट्रिंग को निष्पादित करने के लिए कहता है जैसे कि वे टाइप किए गए थे। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/15-notes == find . -type f -name "*${old}" -execdir sh -c \

एक अच्छी तरकीब जो मैंने डॉकर फ़ाइलें लिखते समय सीखी है वह है बैकस्लैश। इससे आप ज़्यादा पठनीय कोड लिख सकते हैं जिसमें कहा गया है कि हम एक सिंगल लाइन एक्जीक्यूटेबल लिख रहे हैं लेकिन इसमें कई लाइनें होंगी।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/16-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={};'

यहाँ हम केवल फ़ाइलों के लिए वर्तमान निर्देशिका की पुनरावर्ती खोज से स्ट्रिंग पैटर्न से मेल खाने वाले खोज कमांड के परिणामों को कैप्चर और असाइन करते हैं।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/17-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x'

हम कैप्चर किए गए परिणामों को mv कमांड में एक चर के रूप में उपयोग करते हैं। लिनक्स में mv कमांड के दो उपयोग हैं;
पहला फ़ाइल पॉइंटर को वास्तव में एक निर्देशिका से दूसरी निर्देशिका में ले जाना और दूसरा फ़ाइल/निर्देशिका का नाम बदलना जो हम यहाँ कर रहे हैं।
फिर भी यह कमांड का केवल आधा हिस्सा है, हमें अभी भी इस फ़ाइल का नाम बदलने के लिए एक नाम की आवश्यकता है।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/18-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x $(echo $x | sed 's/${old}/${new}/g')'

नया नाम पाने के लिए हमें सबशेल का उपयोग करने की आवश्यकता है, जिसका सीधा सा मतलब है कि हम लिनक्स कमांड का उपयोग करके एक एकल स्ट्रिंग आउटपुट करते हैं जिसे मूव कमांड में प्रतिस्थापित किया जाएगा। किसी कमांड के परिणामों को असाइन करने के कम से कम दो तरीके हैं। हम पहले ही एक तरीका देख चुके हैं, एक उपयोगकर्ता परिभाषित चर के माध्यम से: x={}।

परिणामों का उपयोग करने का दूसरा तरीका सबशेल का उपयोग करना है: $(echo $x | sed 's/${old}/${new}/g')।
यह सबशेल 2 कमांड का उपयोग करता है जो पहले कमांड के आउटपुट को दूसरे में इनपुट के रूप में "पाइप" करता है,
जिसके परिणामस्वरूप एक स्ट्रिंग बनती है।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/19-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x $(echo $x | sed 's/${old}/${new}/g')'

echo बस x द्वारा रखे गए मान को प्रिंट कर रहा है।
इस कमांड के परिणामों से, हम स्ट्रिंग को sed कमांड में पाइप करते हैं।
लिनक्स स्क्रिप्टिंग में sed का उपयोग आमतौर पर फ़ाइलों के साथ किया जाता है, लेकिन वास्तव में sed का उपयोग फ़ाइलों या स्ट्रिंग्स के साथ किया जा सकता है। पहले कमांड के परिणामों से हम स्ट्रिंग में हेरफेर कर सकते हैं।
यह sed कमांड groovy में java की सभी घटनाओं को प्रतिस्थापित कर रहा है। यहाँ कुछ बिंदु, sed '/' के बीच पूर्वोक्त नियमित अभिव्यक्ति का उपयोग करता है, इसलिए यदि आपको एकल स्ट्रिंग के बजाय स्ट्रिंग पैटर्न की आवश्यकता है, तो सुनिश्चित करें कि regex विशेष वर्णों से बचें। एक और बिंदु, '/' वाली स्ट्रिंग से सावधान रहें, इन्हें भी बचने की आवश्यकता है।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/20-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x $(echo $x | sed 's/${old}/${new}/g')' \;

अंत में, हम अपने find कमांड \; के अंत तक पहुँच जाते हैं। जैसा कि हमने देखा है find रिकर्सन पर काम करता है इसलिए \;
रोकने की स्थिति है।

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/21-notes ==
while getopts ":ud" opts; do
...
done

SOLID सिद्धांतों पर वापस आते हुए हम स्क्रिप्टिंग फ़ाइल के लिए फ़्लैग परिभाषित कर सकते हैं। यदि कोई प्रोग्रामिंग से परिचित है तो "while" को प्रवाह नियंत्रित ऑपरेटर माना जाता है; हममें से बाकी लोग यह समझेंगे कि यह तब तक दोहराया जाता है जब तक कि कोई शर्त पूरी न हो जाए। "while" के लिए शर्त या तो "u" या "d" है। getopts का अर्थ है "get options" संभवतः फ़ाइल कॉल से और एक चर "opts" को असाइन करता है। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/22-notes == while getopts ":ud" opts; do case $opts in u) rename "java" "groovy" ;; d) rename "groovy" "java" ;; esac done

केस अधिकांश प्रोग्रामिंग भाषाओं की तरह ही काम करता है, पास किए गए विकल्प के आधार पर हम उसी
फ़ंक्शन को कॉल करते हैं।
=====