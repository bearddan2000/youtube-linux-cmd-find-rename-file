पहली पंक्ति "#!/usr/bin/env bash" पहले पारंपरिक "#!/usr/bin/bash" पर अजीब लग सकती है। पारंपरिक शा बैंग मानता है कि bash प्रोग्राम वहीं है जहाँ उसे होना चाहिए। स्क्रिप्ट में यह लाइन यह धारणा नहीं रखती है, बल्कि यह कहती है कि बैश प्रोग्राम $PATH में कहीं है। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/07-notes == फ़ंक्शन नाम बदलें() एक पुन: प्रयोज्य कमांड या कोड का टुकड़ा बनाने के लिए हम फ़ंक्शन बनाते हैं, निम्नलिखित है कि स्क्रिप्टिंग फ़ंक्शन कैसे लिखा जाता है। शेल स्क्रिप्टिंग में, फ़ंक्शन सामान्य रूप से प्रोग्रामिंग से अलग तरीके से काम करते हैं। एक फ़ंक्शन, जैसा कि नाम से पता चलता है, एक मान लौटाता है। हालाँकि स्क्रिप्टिंग में, फ़ंक्शन सबरूटीन की तरह काम करते हैं, जिसमें वे वास्तव में कुछ भी नहीं लौटाते हैं। फ़ंक्शन में मान कैसे पास किए जाते हैं, इसमें अन्य अंतर देखे जा सकते हैं। प्रोग्रामिंग में, हम फ़ंक्शन नाम के पास पैरामीटर सूचीबद्ध करते हैं, लेकिन हम जल्द ही देखेंगे कि पैरामीटर स्पष्ट के बजाय निहित हैं। =====

local old=$1
local new=$2

अब संक्षेप में फ़ंक्शन बनाम वैश्विक चर के बारे में बात करने के लिए एक अच्छी जगह हो सकती है। फ़ंक्शन चर
केवल उसी फ़ंक्शन के भीतर उपयोग करने योग्य होने चाहिए जिसमें इसे परिभाषित किया गया था। कोड को पुन: प्रयोज्य बनाने के लिए
, फ़ंक्शन परमाणु होना चाहिए; अपने आप संचालित होने की क्षमता होनी चाहिए।

इसलिए परमाणु की भावना में हम कीवर्ड "स्थानीय" में पहला उदाहरण देखते हैं; हम केवल इन चर को फ़ंक्शन के अंदर से एक्सेस करने योग्य बनाना चाहते हैं। इस कीवर्ड के बिना हम इन चर के मानों को एक्सेस कर सकते हैं और संभवतः बदल सकते हैं जिससे त्रुटियों को ढूंढना कठिन हो जाता है।

शेल स्क्रिप्टिंग में जब हम "$" देखते हैं तो हम मान लेते हैं कि यह चर है, फिर भी संख्या विषम हो सकती है।
स्क्रिप्टिंग करते समय हम नाम से नहीं बल्कि स्थिति से पैरामीटर का संदर्भ देते हैं, इसलिए $1 का अर्थ है पहला पैरामीटर पास किया गया।
मापदंडों की गिनती 0 से नहीं बल्कि 1 से शुरू होती है।
