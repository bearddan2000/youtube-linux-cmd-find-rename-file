हम "स्ट्रिंग पैटर्न" क्यों कहते हैं और केवल "स्ट्रिंग" क्यों नहीं? अच्छा सवाल है, एक पैटर्नसुझाव है कि हम सटीक मिलान की तलाश नहीं कर रहे हैं, बल्कि आंशिक मिलान की तलाश कर रहे हैं। * द्वारा निर्दिष्ट आंशिक मिलान केवल स्ट्रिंग के साथ समाप्त होने वाली किसी भी चीज़ को दर्शाता है, इस मामले में $old। यह एक अन्य अवधारणा में आता है जिसे नियमित अभिव्यक्ति कहा जाता है, लेकिन यह इस वीडियो के दायरे से बाहर है। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/13-notes == find . -type f -name "*${old}" -execdir यह वह जगह है जहाँ हम फ्लैग -execdir के साथ इस कमांड की शक्ति पाते हैं। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/14-notes == find . -type f -name "*${old}" -execdir sh -c Execdir न केवल एक फ्लैग है, बल्कि अपने आप में एक कमांड भी है। ऐसा कहा जाता है कि sh -c -execdir के लिए तर्क हैं जो इसे बताते हैं कि किस शेल को निष्पादित करना है। विडंबना यह है कि sh बोर्न शेल है जबकि स्क्रिप्ट को bash का उपयोग करने के लिए कहा जाता है: #!/usr/bin/env bash. यह कैसे संभव है? 1. बोर्न अधिकांश लिनक्स वितरण में स्थापित है, फिर भी bash मुख्य रूप से केवल डेबियन के लिए है। सभी लिनक्स सिस्टम समान नहीं हैं, वितरण और शेल का यह विषय इस वीडियो के दायरे से बाहर है। 2. mv, echo और sed कमांड बोर्न और bash दोनों शेल में शामिल हैं। कोई भी शेल इन कमांड को पढ़ और निष्पादित कर सकता है। -c एक शेल फ्लैग बोर्न\bash है जो इसे निम्न स्ट्रिंग को निष्पादित करने के लिए कहता है जैसे कि वे टाइप किए गए थे। ===== == /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/15-notes == find . -type f -name "*${old}" -execdir sh -c \

एक अच्छी तरकीब जो मैंने डॉकर फ़ाइलें लिखते समय सीखी है वह है बैकस्लैश। इससे आप ज़्यादा पठनीय कोड लिख सकते हैं जिसमें कहा गया है कि हम एक सिंगल लाइन एक्जीक्यूटेबल लिख रहे हैं लेकिन इसमें कई लाइनें होंगी।

