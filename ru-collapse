== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/00-notes ==
Часто при работе с компьютерными файлами мы обнаруживаем, что
нам может потребоваться переименовать некоторые файлы, оставив другие
неизменными.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/01-notes ==
Сегодня я хотел бы продемонстрировать технику, которую нашел
на stackflow.com Моя специальность связана с компьютерными науками,
поэтому мне удобнее всего использовать Linux, поэтому я продемонстрирую,
используя команду find, однако, поскольку Microsoft разработала
Powershell, которая делает многое из того, что делает этот скрипт;
эта техника может быть возможна и в этой технологии.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/02-notes ==
find — это команда Linux, которая рекурсивно ищет в папке и ее
дочерних каталогах шаблон строки. Это предпочтительный способ поиска, поскольку он, по-видимому, является потоковым выполнением поиска.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/03-notes ==
Потоки — это просто причудливый способ выполнения программы
одновременно, или, проще говоря, мы выполняем часть программирования
повторно с условием остановки. Поскольку сегодняшнее видео не
о потоках, мы можем использовать это упрощенное определение.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/04-notes ==
Поскольку find — это команда, действующая по рекурсии, необходимо соблюдать осторожность, чтобы искать только нужные нам папки, поэтому, например, было бы неразумно использовать эту технику во всей файловой системе.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/05-notes ==
Итак, давайте рассмотрим этот простой скрипт:
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/06-notes ==
Первая строка "#!/usr/bin/env bash" на первый взгляд может показаться странной по сравнению с традиционной
"#!/usr/bin/bash". Традиционный sha bang предполагает, что программа bash находится там, где ей следует быть.
Эта строка в скрипте не предполагает этого, вместо этого она говорит, что программа bash находится где-то в
$PATH.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/07-notes ==
function rename()

Чтобы создать повторно используемую команду или фрагмент кода, мы создаем функции, ниже показано, как пишется
функция скрипта. В скриптах оболочки функции работают иначе, чем в обычном программировании. Функция, как следует из названия, возвращает значение. Однако в скриптах функции действуют
больше как подпрограммы, поскольку они на самом деле ничего не возвращают.

Другие различия можно увидеть в том, как значения передаются в функцию. В программировании мы, как правило,
перечисляем параметры рядом с именем функции, но вскоре увидим, что параметры являются неявными, а
явными. =====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/08-notes ==
local old=$1
local new=$2

Теперь, возможно, самое время кратко поговорить о функциональных и глобальных переменных. Функциональные переменные
должны использоваться только внутри функции, в которой они были определены. Чтобы код можно было повторно использовать,
функции должны быть атомарными; должна быть возможность работать самостоятельно.

Так что в духе атомарности мы видим первое вхождение в ключевом слове "local"; мы хотим, чтобы эти
переменные были доступны только изнутри функции. Без этого ключевого слова мы могли бы получить доступ и
возможно изменить значения этих переменных, что затрудняет поиск ошибок.

В скриптах оболочки, когда мы видим "$", мы предполагаем, что это переменные, однако числа могут быть нечетными.
В скриптах мы ссылаемся на параметры по положению, а не по имени, поэтому $1 означает первый переданный параметр.
Подсчет размещений параметров начинается с 1, а не с 0.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/09-notes ==
find

В следующей строке мы видим фактическую команду. find уже идентифицирован, но повторим еще раз: это программа, которая использует потоки для рекурсивного поиска строки или шаблона литерала.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/10-notes ==
find .

После программы find мы видим аргументы, которые передаются программе. Аргументы или иногда называемые флагами, используются в программировании для предоставления программам указаний для выполнения определенных функций.

Здесь наш первый аргумент — это точка, которая в данном контексте означает, что начинается поиск в текущем

каталоге или папке, если вам так больше нравится. Этот период можно изменить, чтобы он указывал на любой каталог,
совет: всегда используйте полные или абсолютные пути.
Для команды find на самом деле неважно, используете ли вы абсолютные или относительные пути, но если вы
используете большой файл скрипта, он просто более читабельный.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/11-notes ==
find . -type f

Далее мы видим -type f, что означает поиск только файлов, однако мы можем искать папки, выполнив
-type d.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/12-notes ==
find . -type f -name "*${old}"

Если вы помните, мы упоминали, что find — это команда, которая будет рекурсивно искать шаблон строки.
Почему мы говорим "образец строки", а не просто "строка"? Хороший вопрос, образец suggest мы не ищем
точного совпадения, а частичного совпадения. Частичное совпадение, как указано *
просто говорит обо всем, что заканчивается строкой, $old в данном случае. Это переходит в другую концепцию,
называемую регулярными выражениями, но это выходит за рамки этого видео.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/13-notes ==
find . -type f -name "*${old}" -execdir

Вот где мы находим силу этой команды с флагом -execdir.
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/14-notes ==
find . -type f -name "*${old}" -execdir sh -c

Execdir — это не только флаг, но и команда сама по себе. При этом sh -c — это аргументы для
-execdir, указывающие, какую оболочку выполнять. По иронии судьбы sh — это оболочка borne, тогда как скрипту
приказано использовать bash: #!/usr/bin/env bash.
Как это возможно?

1. Borne установлен в большинстве дистрибутивов Linux, но bash в первую очередь предназначен только для Debian. Не все
системы Linux одинаковы, эта тема дистрибутивов и оболочек выходит за рамки этого видео.

2. Команды mv, echo и sed включены в оболочки borne и bash. Любая из оболочек может читать и
выполнять эти команды.

-c — это флаг оболочки borne\bash, сообщающий о необходимости выполнить следующую строку, как если бы они были набраны.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/15-notes ==
find . -type f -name "*${old}" -execdir sh -c \

Хороший трюк, которому я научился, написав docker-файлы, — это обратная косая черта. Это позволяет вам писать более
читаемый код, говоря, что мы пишем однострочный исполняемый файл, но строк будет несколько.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/16-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={};'

Здесь мы захватываем и назначаем результаты команды find, которые соответствуют шаблону строки из
рекурсивного поиска текущего каталога только для файлов.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/17-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x'

Мы используем полученные результаты как переменную в команде mv. Команда mv в Linux имеет два применения:
во-первых, для фактического перемещения указателя файла из одного каталога в другой, а во-вторых, для переименования
файла/каталога, что мы здесь и делаем.
Но это только половина команды, нам все еще нужно имя, чтобы переименовать этот файл.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/18-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x $(echo $x | sed 's/${old}/${new}/g')'

Чтобы получить новое имя, нам нужно использовать подоболочку, что просто означает, что мы используем команды linux для
вывода одной строки, которая будет подставлена ​​в команду перемещения. Существует как минимум два способа
назначить результаты команд(ы). Мы уже видели один способ,
через определяемую пользователем переменную: x={}.

Второй способ использования результатов — использовать подоболочку: $(echo $x | sed 's/${old}/${new}/g').
Эта подоболочка использует 2 команды, «передавая» вывод первой команды второй в качестве ввода,
это приводит к одной строке.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/19-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x $(echo $x | sed 's/${old}/${new}/g')'

echo просто выводит значение, хранящееся в x.

Из результатов этой команды мы передаем строку в команду sed.

В скриптах Linux sed обычно используется с файлами, но на самом деле sed можно использовать как с файлами, так и со строками. С результатами первой команды мы можем манипулировать строкой.

Эта команда sed заменяет все вхождения java на groovy. Несколько моментов: sed использует
вышеупомянутое регулярное выражение между '/', поэтому, если вам нужен шаблон строки вместо
одной строки, обязательно экранируйте специальные символы регулярных выражений. Еще один момент: будьте осторожны со
строками, содержащими '/', их тоже нужно экранировать.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/20-notes ==
find . -type f -name "*${old}" -execdir sh -c \
'x={}; mv $x $(echo $x | sed 's/${old}/${new}/g')' \;

Наконец, мы достигаем конца нашей команды find \;. Как мы видели, find работает на рекурсии, поэтому \;
— это условие остановки.

=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/21-notes ==
while getopts ":ud" opts; do
...
done

Возвращаясь к принципам SOLID, мы можем определить флаги для самого файла скрипта. Если
кто-то знаком с программированием, "while" считается оператором управления потоком; остальные из нас
поймут, что он повторяется, если не выполняется условие. Условие(я) для "while" - это
либо "u", либо "d". getopts означает "get options", предположительно из вызова файла, и присваивает
переменной "opts".
=====

== /home/oem/git/youtube/youtube-linux-cmd-find-rename-file/en/22-notes ==
while getopts ":ud" opts; do
case $opts in
u)
rename "java" "groovy" ;;
d)
rename "groovy" "java" ;;
esac
done

case работает так же, как и в большинстве языков программирования, на основе переданной опции мы вызываем ту же
функцию.
=====